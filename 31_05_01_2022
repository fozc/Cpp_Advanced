/*


VIEWSTA KALMIŞTIK
Projection parametresi ile ilgili bir tekrar yapılacak ufak. Projection ile algoritma içinde belirli veya birden fazla noktada
algoritmanın gördüğü öğenin ne olacağını biliyoruz.Yani range deki öğenin kendisi mi yoksa algoritma o öğeyi kullandığı 1 veya 
daha fazla yerde başka birşey mi görsün ? Bunu belirlemeye yarıyor.

ÇOK ÖNEMLİ ÖRNEK

#include<ranges>
#include<functional>

template<std::input_iterator Iter, std::sentinel_for<Iter> S, typename T, typename Proj = std::identity>
auto Find(Iter beg, S end, const T& val, Proj proj = {})	// S ile iter aynı tür oladabilir olmayadabilir.
{															
	while(beg != end)
	{
		if(std::invoke(proj, *beg) == val) // invoke proj çağırıyor ve *beg'i argüman olarak gönderiyor.
		{								   // Data member ptr de gönderildiğidne yine çağrı yapsın diye invoke var.
										   // default argüman kullanırsak identity olacak proj. İdentity de *beg değerini verir
											
			return beg;
		}

		++beg;
	}

	return beg;
}

int main()
{
	using namespace std;

	vector ivec{10,5,6,400,4,6,20,9,2};

	if(auto iter = Find(ivec.begin(), ivec.end(), 400); iter != ivec.end())
	{
		cout << "bulundu " << *iter << '\n';
		cout << "index = " << distance(ivc.begin(), iter)<< '\n';
	}
	else
	{
		std::cout << "bulunamadi\n";
	}

	-----------------------------------------------------------------------------------------

	4. ARGÜMANA IDENTITY YERINE KENDI PARAMETREMI GEÇIYORUM

	vector ivec{10,5,6,400,4,6,20,9,2};

	if(auto iter = Find(ivec.begin(), ivec.end(), 400,[](int x){ return x * x; }); iter != ivec.end()) // Kendisi değil karesi 400 e eşit olanı bulacak
	{																									// bu değerde 20
		cout << "bulundu " << *iter << '\n';	
		cout << "index = " << distance(ivc.begin(), iter)<< '\n';
	}
	else
	{
		std::cout << "bulunamadi\n";
	}

}


----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------

ÖNEMLİ NOKTALAR:
Bu yeni algoritmaların return değeri türleri her zaman eski algoritmalarla aynı değil.Bu çok büyük fayda sağlayan mekanizma için
oluşturulmuş.

Yeni algoritmalarda avantaj var. İterator çifti yerine doğrudan range conceptlerinden birini yada birden
fazlasını satisfied eden nesneyi geçebiliyoruz.

int main()
{
	auto vec = getvec(100,0,1000);
	print(vec);

	// ranges::sort(vec); // algoritma iteratör dündürüyor ama range parametresine biz lvalue expr yerine rvalue expr gönderiyoruz.

	auto iter = ranges::min_element(vec);

	std::cout << "min = " << *iter << " iter = " << iter - vec.begin() << '\n';

	-----------------------------------------------------------------------------------------------------------

	ALGORITMAYA RVALUE EXPR GEÇERSEK !!!!!!!!!!!!!
	BU ESKİDEN OLMAYAN BİR PROBLEM !!!!!!!!!!!

	auto iter = ranges::min_element(getvec(10,0,100000)); // Sentaks hatası. getvec(10,0,100000) bu bir prvalue expr. ifadenin çalıştıktan sonra 
														  // Dolayısı ile buradaki iterator dangling iterator olacak.
														  // Vectorun ömrü bitiyor. Dolayısı ile buradaki iterator bir dangling iterator olacak.

}

2 TANE SEÇENEĞI VAR LIBRARY TASARLAYANLARIN
1 - Range parametresi olan algoritmaya pr value expr ile çağrı yapmak doğrudan compile timeda hata olacak.Bunu tercih etmemişler
2 - iteratörü indirection operandı yapınca (*iter) sentaks hatası oluyor. Nasıl oldu bu ?

Compile time teknikleriyle func sağ taraf değeri aldığında return değeri özel bir return değeri.
Bu ranges::dangling'i denilen bir değer. vector<int>::iterator değil. Bunu compile timeda anlıyor.
Bu tür indirectionun operandı olunca sentaks hatası oluşuyor.

NEDEN BÖYLE TASARLAMIŞLAR?
Bunun nedeni algoritmaya range parametresine sağ taraf değeri geçtiğimiz zaman sentaks hatası olmasını istememişler.
Bunun cevabı C++20 ile gelen barrowed range isimli kavram. Range isteyen algoritmalar ya bir lvalue range geçmek zorunda
yada rvalue range geçilirse eğer return değeri iterator ise o iteratörün kullanılabilmesi için bunun barrowed range olması gerekiyor.

BARROWED RANGE : Bu rangelerin iteratörlerinin dangling olma ihtimali doğrudan mevcut değil.
Bir rvalue vector bir barrowed range değil.

Spani düşünelim

int main()
{
	auto vec = getvec(10,0,100000);

	auto iter = ranges::min_element(span(vec)); // span(vec)'te bir rvalue expr.iter burada dangling iterator değil.

	std:cout << "min = " << *iter; // yukarıdaki iterator dangling değil. dangling iteratorü indirection yapınca sentaks hatası oluyor
}

BURADA NASIL KOD ÜRETILDI ? 
Derleyici funca gönderilen türün bir rvalue expr olmasına rağmen bunun bir barrowed range olduğunu tür sistemindeki
araçları kullanarak anladı.

BARROWED RANGE IÇIN 2 IHTIMAL VAR
1- Lvalue range olacak
2- Variable template var. İsmi enable barrow range. O tür için explicit specialization yapılmış std library'de. 
   Ve inline variable'ın değerini true yapacağız.


template<>
inline constexpr bool std::ranges::enable_borrowed_range<Myclass> = true;

Yani tür sistemine barrowed range olduğunu anlatmak için bu inline variable ın true değerde olması gerekiyor.

----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------

YANI BIR ALGORITMAYA BIR RANGE GÖNDERILMESI GEREKIYORSA LVALUE RANGE OLACAK YADA BARROWED RANGE NİTELİĞİNE SAHİP
OLMASI İÇİN AZ ÖNCEKİ GİBİ DEĞİŞKENİN DEĞERİNİN TRUE OLMASI GEREKİYOR

----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------

FARKLAR NELER? 

1 - Function return değeri duruma göre compile timeda iterator yada ranges dangling türü olabiliyor.
Böylece dangling türünden değeri dereference ettiğimizde yada işlemlere soktuğumuzda sentaks hataso oluşuyor.
Böylece algoritmalara eğer uygunsa rvalue expr olan bir rangei geçebiliyoruz.Uygun değilse aldığımız iteratörü
dereference edince compile timeda hata oluşuyor

2 - Projectin parametresi

3 - Algoritmaların hepsinin constraint edilmesi

============================================================================================================================
============================================================================================================================
============================================================================================================================

ÖNEMLI EKSIKLIKLER VAR.

1- Numerics header file içinde numetric algoritmaların henüz ranges karşılıkları yok.Bunları constraint etme biraz zor olduğundan
   yapacak zaman kalmmamış. C++23 e kalmış

2- Algoritmalar paralel olarak çalıştırılabiliyor.Kendimiz doğrudan thread oluşturmadan algoritmanın 1. overloaduna özel bir
   değer geçerek algoritmanın paralel çalışmasını sağlayabiliriz. Bu özellik rangeste yok !!!!!
   C++23 te muhtemelen eklenecek

============================================================================================================================
============================================================================================================================
============================================================================================================================

ACCULUMATE ALGORİTMASI

STL 1.0 dan STL 2.0 a kadar getireceğiz :D:D
Bu algoritma bir range deki öğeleri kümülatif olarak işleme sokuyor. bu işlemde tipik olarak toplama.

int main()
{
	auto ivec = getvec(100,0,2000);
	print(ivec);

	auto val = accumulate(ivec.begin(), ivec.end(),0);  // üretilen 100 sayıyı topladı. initial value da 0.
														// rangedeki öğeler toplanmasın ama şu işlem olsun dersek onuda algoritmanın diğer overloaduna
														// 4. parametre olarak geçebiliriz. Defaultta toplama işlemi.
	std::cout << "val = " << val << '\n';				
}

---------------------------------------------------------------------------------------------------------------------------

ESKİ HALİ AŞAĞIDAKİ GİBİ

template<typename Iter, typename Init>
Init Accumulate1(Iter beg, Iter end, Init init)
{
	while(beg != end)
	{
		init = std::move(init) + *beg;
		++beg;
	}

	return init;
}

---------------------------------------------------------------------------------------------------------------------------

TEMPLATE PARAMETRELERİ GELDİ.SENTINEL VE OPERATION

template<typename Iter,typename SenType, typename Init, typename Op = std::plus<>>
Init Accumulate2(Iter beg, SenType end, Init init, Op op = {})
{
	while(beg != end)
	{
		init = op(std::move(init), *beg); 
		++beg;
	}

	return init;
}

-------------------------------------------------------------------------------------------------

CONCEPTLER İLE CONSTRAINT EDELİM

template<typename Iter,typename SenType, typename Init, typename Op = std::plus<>>
requires std::input_iterator<Iter> && std::sentinel_for<Iter,SenType> 
Init Accumulate3(Iter beg, SenType end, Init init, Op op = {})
{
	while(beg != end)
	{
		init = op(std::move(init), *beg);
		++beg;
	}

	return init;
}

-------------------------------------------------------------------------------------------------

CONSTRAINT TEMPLATE PARAMETRESİ YAPALIM

template<std::input_iterator Iter, std::sentinel_for<Iter> SenType, typename Init, typename Op = std::plus<>>
Init Accumulate4(Iter beg, SenType end, Init init, Op op = {})
{
	while(beg != end)
	{
		init = op(std::move(init), *beg);
		++beg;
	}

	return init;
}

-------------------------------------------------------------------------------------------------

INVOKE GELDİ

template<std::input_iterator Iter, std::sentinel_for<Iter> SenType, typename Init, typename Op = std::plus<>>
Init Accumulate5(Iter beg, SenType end, Init init, Op op = {})
{
	while(beg != end)
	{
		init = std::invoke(op, std::move(init), *beg);
		++beg;
	}

	return init;
}


-------------------------------------------------------------------------------------------------

INITTE DEFAULT ARGÜMAN ALACAK

template<std::input_iterator Iter, std::sentinel_for<Iter> SenType, typename Init = std::iter_value_t<iter>, typename Op = std::plus<>>
Init Accumulate6(Iter beg, SenType end, Init init = Init{}, Op op = {})
{
	while(beg != end)
	{
		init = std::invoke(op, std::move(init), *beg);
		++beg;
	}

	return init;
}

iter_value_t = bu hangi argümanı verirsek o iteratör konumundaki türü alıyor.
iter_value_t< vector<int>::iterator > burası int olacak

Init init = Init{} primitive türler için değer 0, sınıf türleri için default ctor çağrılacak.

-------------------------------------------------------------------------------------------------

PROJECTION PARAMETRESI EKLİYORUZ EN SONDA

template<std::input_iterator Iter, std::sentinel_for<Iter> SenType, typename Init = std::iter_value_t<iter>, typename Op = std::plus<>,typename Proj = std::identity>
Init Accumulate7(Iter beg, SenType end, Init init = Init{}, Op op = {}, Proj proj = {})
{
	while(beg != end)
	{
		init = std::invoke(op, std::move(init), std::invoke(proj,beg)); // Burasıda değişti !!!!!
		++beg;
	}

	return init;
}

-------------------------------------------------------------------------------------------------

Bunlar iteratör parametreli overloadlardı.Range parametreli overload var ve bu da yine iterator parametreli overloadu çağırıyor.

template<std::ranges::input_range R, class Init = std::ranges::range_value_t<R>, typename Op = std::plus<>, typename Proj = std::identity>
Init Accumulate(R &&r, Init init = Init{}, Op op = {}, Proj proj = {})
{
	return Accumulate(std::ranges::begin(r), std::ranges::end(r),std::move(init), std::move(op), std::move(proj)); 
}	// DİKKAT!!! Parametrelerde range olanlar var.

MOLA


========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================


ÖNEMLI ARAÇLARDAN BIRI SUBRANGE DENEN SINIF ŞABLONU LIGHTWEIGHT OLARAK BUNU KULLANIYORUZ.

using namespace std;

int main()
{
	auto ivec = getvec(20,0,100);

	ranges::subrange sr1{ ivec }; // Ctad dan faydalandık

	cout << "sizeof(sr1) = " << sizeof(sr1) << '\n'; // 8
	
	---------------------------------------------------------------
	
	ÜYE FUNCTIONLAR
	
	std::cout << sr1.size() << '\n'; // Rangedeki öğe sayısını verir

	sr1.data();
	sr1.front();

	sr1.advance(5);
	// rangei daraltmış olduk

	---------------------------------------------------------------

	DİKKAT!!!

	ranges::subrange sr{ivec.begin(), ivec.end()};

	for(auto x : sr)
	{
		std::cout << x << ' ';
	}

	---------------------------------------------------------------

	for(auto iter = sr.begin(); iter != sr.end(); ++iter)
	{
		//..
	}
	
	---------------------------------------------------------------

	ranges::for_each(sr,[](int x){ std::cout << x << " ";});

	---------------------------------------------------------------

	Subrange tuple like interface e sahip.
	
	auto [beg,end] = sr;

	next ve prev functionlarıda var.
	
}



Diyelimki 2 tane iterator var elimde. Bir algoritma yazdık ama bu algoritmada bu rangei 
doğrudan range nesnesi olarak ifade etmek istiyoruz diyelim. Belki range parametreli algoritmaya 
çağrı yapacağız. Bu durumda subrange oluşturabiliriz.

template<typename Iter>
void func(Iter beg, Iter end)
{
	subrange sr{beg, end};
}

Bazı range adaptörleri belirli türden argüman aldıklarında bir subrange döndürüyorlar.
Bazı durumlarda subrangei kendimiz oluşturacağız bazende kullandığımız function bize subrange verecek.

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------


VIEW SINIFLARI

Hafifsiklet range ler.Geçen ders burada kaldık. Default ctor edilebilir destroy edilebilir.
copy maliyeti taşıma maliyeti düşük. Bunlar composable.ya type sentaksı ile compose ediyorum 
yada bu sınıflar türünden nesneleri başka view sınıfları ctoruna argüman olarak gönderiyoruz.

Bunların olayı önemli özelliği bir davranışı encapsule edip dolaşma sırasında 
lazy evaluation ile bir bunları dolaşırken önce range deki öğe birtakım işlemlere sokulabilir.


View Class
----------
std::ranges::filter_view    sınıf
std::ranges::view::filter   range adaptör 
std::views::filter    views aynı zamanda namespace alias olduğundan buda geçerli

transform_view
take_view
take_while_view
drop_view
drop_while_view
reverse_view
join_view
split_view
common_view
keys_view
values_view

Range Factories (view factories)
--------------------------------
Bunların farkı, range'in sahibi durumundalar. Bir containera referans tutmuyorlar.Doğrudan sahibi.
iota_view
single_view
empty_view
basic_istream_view


Hepsi olmasada çoğunu döndüren range adaptörleri var.


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

Filter View
-----------
Bir predicate e bağlı olarak filtre edilmiş bir range döndürüyor.

int main()
{
	auto ivec = getvec(100,0,100);

	
	ranges::filter_view vw{ivec, [](int x){ return x % 5 == 0;}}; // sınıf bu
	
	auto vw = views::filter{ivec, [](int x){ return x % 5 == 0;}}; // range adapter
	
	auto vw = ivec | views::filter{[](int x){ return x % 5 == 0;}}; // buda geçerli.
	// Burada herhangibir lambda ifadesi çağrılıyor dğeil. Bu ancak range dolaşıldığında
	// çağrılacak. Bu yüzden lazy evaluation deniyor.

	for(auto i : vw)
	{
		std::cout << i << " "; // 5 e bölünenler geldi bizde dolaştık
	}
}

----------------------------------------------------------------------------------------------------------

İstersek biren fazla view compose edilebilir


int main()
{
	auto ivec = getvec(100,0,100);
	
	//Birden fazla view compose edilebilir.
	ranges::transform_view (ranges::filter_view{ivec, [](int x){ return x % 5 == 0}}, İKİNCİ_PARAMETRE);

	---------------------------------------------------------------------------------------------

	//Yada adaptörden aldığım değeri diğer adaptöre argüman olaran geçebiliyorum.
	views::transform(view::filter(ivec,[](int x){return x % 5 == 0}), [](int x){ return x * x  - 1;});
}

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

TAKE
---------
Take range adaptörü range_view döndürüyor. Rangedeki öğelerden n tanesini almış oluyoruz.

int main()
{
	auto ivec = getvec(40,0,100);
	print(ivec);
	
	for(auto i : views::take(ivec,10))
	{
		std::cout << i << ' '; // ilk 10 taneyi aldı
	}	
}

----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

DROP
----
Take in tam tersi. Verdiği tamsayı kadar olanı range e dahil etmiyor.

int main()
{
	auto ivec = getvec(40,0,100);
	
	for(auto i : views::drop(ivec,10))
	{
		std::cout << i << ' ';
	}	// ilk 10 tanesini attı geriye kalanı aldı
}


----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------

TAKE_WHILE - DROP_WHILE
-----------------------
Yeni bir tamsayı alıyorlar ama bir predicate alıyorlar.
TAKE WHILE : Range üzerinde, predicate'ı sağlayan öğeye kadar range'i alıyor. sağlamayan olursa bundan sonrasını almıyor.

TAKE WHILE ÖRNEĞI

int main()
{
	auto ivec = getvec(40,0,100);
	print(ivec);
	
	std::cout << "Degeri girin : ";
	cin >> ival;
	
	int ival;

	for( auto i : ivec | views::take_while([ival](int x){ return x > ival; })) // range i pipe ile bağladık
	{
		cout << i <<  ' ';  // 40 72 75 63 57 19 25 30 ve 23 girersek, SONUC : 40 72 75 63 57
	}
}


int main()
{
	
	list<string> slist;
	rfill(slist);
	
	print(slist);
	
	size_t len;
	std::cout << "uzunluk değeri girin: ";
	
	cin >> len;
	
	auto v = views::take_while(slist,[](const string &s){return s.size() > len; })
	
	ranges::for_each(v,[](const auto &s){ std::cout << quoted(s) << " "; });
	// uzunluğu girineln değeri karşılayanları alacak ilk karşılamayandan sonrasını almayacak	
}

----------------------------------------------------------------------------------------------------------

LAZY EVALUATION 
örnek üzerinde görelim.views are lazy

int main()
{
	auto odd = [](int){
		
		std::cout << "odd => x = " << x << '\n'; 
		return x % 2 != 0;
	};
	
	auto cube = [](int y){
		
		std::cout << "cube => y = " << y << '\n';
		return y * y * y;
	};
	
	auto vec = getvec(20,0,30);
	
	auto v = vec | views::filter(odd) | views::transform(cube);
	// şu ana kadar ekrana birşey çıkmaz. Çünkü rangei dolaşmadık.
	// ne zaman range dolaşılırsa o zaman bu işlemler yapılır.
	// Bu yönteme programlamada pull metod deniyor.
	
	for(auto i : v )
	{
		std::cout << "i = " << i << "\n"; // artık ekrana çıktılar verilir.		
	}
	1.48
}


*/
